generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}



model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique      
  name      String
  email     String   @unique
  password  String?               
  conversations Conversation[] @relation("UserConversations")
  conversationReads ConversationReads[]
  createdAt DateTime @default(now())

  isPremium Boolean  @default(false)
  premiumEndsAt DateTime?

  profileViewsReceived ProfileView[] @relation("ProfileViewOwner")
  profileViewsMade     ProfileView[] @relation("ProfileViewViewer")

  profile   Profile?

  posts     Post[]
  comments  Comment[]
  likes     Like[]
  jobs         Job[]
  applications JobApplication[]
  notifications        Notification[] @relation("UserNotifications")
  sentNotifications    Notification[] @relation("SenderNotifications")

  sentConnections     Connection[] @relation("SentConnections")
  receivedConnections Connection[] @relation("ReceivedConnections")
}


model ProfileView {
  id        String   @id @default(uuid())

  viewerId  String
  ownerId   String

  viewer User @relation("ProfileViewViewer", fields: [viewerId], references: [id])
  owner  User @relation("ProfileViewOwner", fields: [ownerId], references: [id])

  createdAt DateTime @default(now())

  @@unique([viewerId, ownerId])
}



model JobApplication {
  id        String   @id @default(uuid())

  
  jobId     String
  job       Job      @relation(fields: [jobId], references: [id])

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  status    ApplicationStatus @default(APPLIED)

  createdAt DateTime @default(now())

  @@unique([jobId, userId]) 
}



model Job {
  id            String   @id @default(uuid())

  title         String
  company       String
  location      String
  type          JobType
  workplace     WorkplaceType
  description   String

  // Salary
  salaryMin     Int?
  salaryMax     Int?



  skills        String[]
  isOpen        Boolean  @default(true)

  // Relations
  userId        String
  user          User     @relation(fields: [userId], references: [id])

  applications  JobApplication[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}


enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}

enum WorkplaceType {
  ONSITE
  HYBRID
  REMOTE
}

enum ApplicationStatus {
  APPLIED
  REVIEWING
  SHORTLISTED
  REJECTED
  HIRED
}





model Message {
  id             String   @id @default(uuid())
  text           String?
  senderId       String
  conversationId String
  createdAt      DateTime @default(now())

  type           MessageType @default(TEXT)
  sharedPostId   String?
  sharedPost     Post?       @relation(fields: [sharedPostId], references: [id])

  conversation Conversation @relation(fields: [conversationId], references: [id])
}

enum MessageType {
  TEXT
  POST
}

model Conversation {
  id        String   @id @default(uuid())
  members   User[]   @relation("UserConversations")
  messages  Message[]

  // Relation to track read messages
  conversationReads ConversationReads[] @relation("ConversationReadRelation")

  createdAt DateTime @default(now())
}

model ConversationReads {
  id             String   @id @default(uuid())
  userId         String
  conversationId String
  lastReadAt     DateTime @default(now())

  user           User         @relation(fields: [userId], references: [id])

  // ðŸ”¥ Add the relation name to match Conversation
  conversation   Conversation @relation("ConversationReadRelation", fields: [conversationId], references: [id])

  @@unique([userId, conversationId])
}



model Profile {
  id        String   @id @default(uuid())
  bio       String?
  location  String?
  image     String?
  coverImg  String?
  headline  String?

  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  education  Education[]
  experience Experience[]
}

model Education {
  id         String   @id @default(uuid())
  institute  String
  degree     String
  year       String

  profileId  String
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
}

model Experience {
  id         String   @id @default(uuid())
  company    String
  role       String
  duration   String

  profileId  String
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
}

model Post {
  id        String   @id @default(uuid())
  caption   String
  image     String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  comments  Comment[]
  likes     Like[]
  sharedMessages Message[]

  createdAt DateTime @default(now())
}

model Comment {
  id        String   @id @default(uuid())
  content   String

  postId    String
  userId    String

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

model Like {
  id        String   @id @default(uuid())
  userId    String
  postId    String

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
}

model Connection {
  id          String   @id @default(uuid())
  senderId    String
  receiverId  String
  status      ConnectionStatus
  createdAt   DateTime @default(now())

  sender      User     @relation("SentConnections", fields: [senderId], references: [id])
  receiver    User     @relation("ReceivedConnections", fields: [receiverId], references: [id])

  @@unique([senderId, receiverId])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}


model Notification {
  id        String   @id @default(cuid())
  userId    String
  senderId  String?
  type      NotificationType
  message   String
  entityId  String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user   User  @relation("UserNotifications", fields: [userId], references: [id])
  sender User? @relation("SenderNotifications", fields: [senderId], references: [id])


}

enum NotificationType {
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  POST_LIKE
  POST_COMMENT
  MESSAGE
}


